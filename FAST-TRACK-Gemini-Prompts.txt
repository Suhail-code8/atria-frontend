===============================================================================
           FAST TRACK - UNDERSTAND YOUR CODE QUICKLY WITH GEMINI
===============================================================================

Copy each prompt + code into Gemini. Get answers fast. No theory.

===============================================================================
PROMPT 1: UNDERSTAND YOUR EVENT MODEL
===============================================================================

Explain this Event model code line by line. What does each part do?

```typescript
import mongoose, { Schema, Document } from "mongoose";

export enum EventType {
  CONFERENCE = "CONFERENCE",
  FEST = "FEST",
  PROGRAM = "PROGRAM",
  CUSTOM = "CUSTOM"
}

export enum EventStatus {
  DRAFT = "DRAFT",
  PUBLISHED = "PUBLISHED",
  REGISTRATION_OPEN = "REGISTRATION_OPEN",
  ONGOING = "ONGOING",
  COMPLETED = "COMPLETED",
  CANCELLED = "CANCELLED",
  ARCHIVED = "ARCHIVED"
}

export interface EventCapabilities {
  registration: boolean;
  submissions: boolean;
  review: boolean;
  teams: boolean;
  scoring: boolean;
  sessions: boolean;
  realtime: boolean;
}

export interface IRegistrationFormField {
  id: string;
  label: string;
  type: 'text' | 'number' | 'email' | 'select' | 'checkbox' | 'textarea';
  required: boolean;
  options?: string[];
  placeholder?: string;
}

export interface IEvent extends Document {
  title: string;
  description: string;
  eventType: EventType;
  startDate: Date;
  endDate: Date;
  registrationStartDate?: Date;
  registrationEndDate?: Date;
  createdBy: mongoose.Types.ObjectId | string | IUser;
  isPublic: boolean;
  status: EventStatus;
  capabilities: EventCapabilities;
  registrationForm?: IRegistrationFormField[];
  createdAt?: Date;
  updatedAt?: Date;
}

const eventSchema = new Schema<IEvent>(
  {
    title: { type: String, required: true, trim: true },
    description: { type: String, required: true, trim: true },
    eventType: { type: String, enum: Object.values(EventType), required: true },
    startDate: { type: Date, required: true },
    endDate: { type: Date, required: true },
    registrationStartDate: { type: Date },
    registrationEndDate: { type: Date },
    createdBy: { type: Schema.Types.ObjectId, ref: "User", required: true },
    isPublic: { type: Boolean, default: true },
    status: { type: String, enum: Object.values(EventStatus), default: EventStatus.DRAFT },
    capabilities: {
      registration: { type: Boolean, default: false },
      submissions: { type: Boolean, default: false },
      review: { type: Boolean, default: false },
      teams: { type: Boolean, default: false },
      scoring: { type: Boolean, default: false },
      sessions: { type: Boolean, default: false },
      realtime: { type: Boolean, default: false }
    },
    registrationForm: [{
      id: { type: String, required: true },
      label: { type: String, required: true },
      type: { type: String, enum: ['text', 'number', 'email', 'select', 'checkbox', 'textarea'], required: true },
      required: { type: Boolean, default: false },
      options: [{ type: String }],
      placeholder: { type: String }
    }]
  },
  { timestamps: true }
);

export const Event = mongoose.model<IEvent>("Event", eventSchema);
```

Questions:
1. What is each enum for?
2. What does the ? mean in fields?
3. What is Schema.Types.ObjectId?
4. How does the capabilities object work?
5. What is registrationForm array storing?

===============================================================================
PROMPT 2: UNDERSTAND EVENT CREATION COMPONENT
===============================================================================

Explain this CreateEvent component. How does it work?

```tsx
export const CreateEvent = () => {
  const navigate = useNavigate()
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    eventType: 'CONFERENCE' as EventType,
    startDate: '',
    endDate: '',
    registrationStartDate: '',
    registrationEndDate: '',
    isPublic: true,
    capabilities: {
      registration: false,
      submissions: false,
      review: false,
      teams: false,
      scoring: false,
      sessions: false,
      realtime: false
    }
  })
  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(false)

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target as any
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? (e.target as HTMLInputElement).checked : value
    }))
  }

  const handleCapabilityChange = (capability: keyof typeof formData.capabilities) => {
    setFormData(prev => ({
      ...prev,
      capabilities: {
        ...prev.capabilities,
        [capability]: !prev.capabilities[capability]
      }
    }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError('')
    setIsLoading(true)

    try {
      const response = await eventsApi.createEvent(formData)
      navigate(`/events/${response.data.data._id}`)
    } catch (err: any) {
      setError(getErrorMessage(err))
    } finally {
      setIsLoading(false)
    }
  }
```

Questions:
1. What is useState doing?
2. How does handleChange work?
3. What is ...prev doing?
4. How does handleCapabilityChange toggle capabilities?
5. What happens in handleSubmit step by step?
6. What is async/await doing?

===============================================================================
PROMPT 3: UNDERSTAND EVENT LIFECYCLE
===============================================================================

Explain this event lifecycle code. How do state transitions work?

```typescript
const allowedTransitions: Record<EventStatus, EventStatus[]> = {
  [EventStatus.DRAFT]: [EventStatus.PUBLISHED, EventStatus.CANCELLED],
  [EventStatus.PUBLISHED]: [EventStatus.REGISTRATION_OPEN, EventStatus.CANCELLED, EventStatus.ARCHIVED],
  [EventStatus.REGISTRATION_OPEN]: [EventStatus.ONGOING, EventStatus.CANCELLED],
  [EventStatus.ONGOING]: [EventStatus.COMPLETED, EventStatus.CANCELLED],
  [EventStatus.COMPLETED]: [EventStatus.ARCHIVED],
  [EventStatus.CANCELLED]: [EventStatus.ARCHIVED],
  [EventStatus.ARCHIVED]: []
};

const validateTransition = (currentState: EventStatus, targetState: EventStatus) => {
  const allowed = allowedTransitions[currentState];
  if (!allowed.includes(targetState)) {
    const error: any = new Error(`Invalid transition from ${currentState} to ${targetState}`);
    error.statusCode = 400;
    throw error;
  }
};

const validatePreconditions = (event: IEvent, targetState: EventStatus) => {
  const now = new Date();

  switch (targetState) {
    case EventStatus.PUBLISHED:
      if (!event.title || !event.description) {
        throwError("Event must have title and description before publishing");
      }
      if (!event.startDate || !event.endDate) {
        throwError("Event must have valid start and end dates");
      }
      if (event.endDate <= event.startDate) {
        throwError("Event end date must be after start date");
      }
      break;

    case EventStatus.REGISTRATION_OPEN:
      if (!event.capabilities.registration) {
        throwError("Registration capability not enabled");
      }
      if (!event.registrationStartDate || !event.registrationEndDate) {
        throwError("Registration window must be defined");
      }
      if (event.registrationEndDate <= event.registrationStartDate) {
        throwError("Registration end date must be after start date");
      }
      break;

    case EventStatus.ONGOING:
      if (now < event.startDate) {
        throwError("Event cannot start before start date");
      }
      break;

    case EventStatus.COMPLETED:
      if (now < event.endDate) {
        throwError("Event cannot complete before end date");
      }
      break;
  }
};

export const transitionEventState = async (
  eventId: string,
  targetState: EventStatus,
  actorId: string
): Promise<IEvent> => {
  const event = await Event.findById(eventId);
  if (!event) throwError("Event not found");
  if (event.createdBy.toString() !== actorId) {
    throwError("Forbidden: Only event creator can transition state");
  }

  const currentState = event.status;
  if (currentState === targetState) {
    throwError(`Event is already in ${targetState} state`);
  }

  validateTransition(currentState, targetState);
  validatePreconditions(event, targetState);

  event.status = targetState;
  await event.save();
  return event;
};
```

Questions:
1. What is allowedTransitions doing?
2. How does validateTransition prevent invalid changes?
3. What checks does validatePreconditions do?
4. Walk me through: DRAFT → PUBLISHED → REGISTRATION_OPEN
5. Why can't I go from DRAFT to ONGOING directly?

===============================================================================
PROMPT 4: UNDERSTAND API CLIENT
===============================================================================

Explain this API code. How do I call these functions?

```typescript
export const eventsApi = {
  listEvents: () =>
    axiosInstance.get<{ success: boolean; data: Event[] }>('/events'),

  getMyEvents: () =>
    axiosInstance.get<{ success: boolean; data: Event[] }>('/events?organizerId=ME'),

  getEvent: (eventId: string) =>
    axiosInstance.get<{ success: boolean; data: Event }>(`/events/${eventId}`),

  createEvent: (data: Partial<Event>) =>
    axiosInstance.post<{ success: boolean; data: Event }>('/events', data),

  updateEvent: (eventId: string, data: Partial<Event>) =>
    axiosInstance.put<{ success: boolean; data: Event }>(`/events/${eventId}`, data),

  deleteEvent: (eventId: string) =>
    axiosInstance.delete<{ success: boolean; data: Event }>(`/events/${eventId}`),

  transitionEvent: (eventId: string, targetState: EventStatus) =>
    axiosInstance.post<{ success: boolean; message: string; data: Event }>(
      `/events/${eventId}/transition`,
      { targetState }
    ),

  getEventAnalytics: (eventId: string) =>
    axiosInstance.get<{ success: boolean; data: EventAnalytics }>(
      `/events/${eventId}/analytics`
    )
}
```

Questions:
1. What is axiosInstance.get/post/put/delete doing?
2. What does <{ success: boolean; data: Event }> mean?
3. How do I use createEvent in my component?
4. Show me example of calling getEvent with eventId
5. How does error handling work with these?

===============================================================================
PROMPT 5: UNDERSTAND BACKEND CONTROLLER
===============================================================================

Explain this controller code. What happens when API is called?

```typescript
export const createEvent = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user?.userId as string;
    
    const { 
      title, 
      description, 
      eventType, 
      startDate, 
      endDate, 
      isPublic,
      registrationStartDate,
      registrationEndDate,
      capabilities,
      registrationForm
    } = req.body;

    const event = await eventService.createEvent({
      title, 
      description, 
      eventType, 
      startDate, 
      endDate, 
      isPublic,
      registrationStartDate, 
      registrationEndDate,
      capabilities,
      registrationForm
    }, userId);

    res.status(201).json({ success: true, data: event });
  } catch (err) {
    next(err);
  }
};

export const updateEvent = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const userId = req.user?.userId as string;
    const eventId = req.params.eventId as string;
    const event = await eventService.updateEvent(eventId, req.body, userId);
    res.status(200).json({ success: true, data: event });
  } catch (err) {
    next(err);
  }
};

export const transitionEvent = async (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  try {
    const eventId = req.params.eventId as string;
    const { targetState } = req.body;

    if (!targetState || !Object.values(EventStatus).includes(targetState)) {
      const error: any = new Error("Invalid target state");
      error.statusCode = 400;
      throw error;
    }

    const updatedEvent = await transitionEventState(
      eventId,
      targetState,
      req.user!.userId,
    );

    res.status(200).json({
      success: true,
      message: `Event transitioned to ${targetState}`,
      data: updatedEvent,
    });
  } catch (error) {
    next(error);
  }
};
```

Questions:
1. What is req, res, next?
2. How does req.body get the form data?
3. What is req.user?.userId?
4. What does await eventService.createEvent do?
5. What happens in try-catch?
6. How does the response get back to frontend?

===============================================================================
PROMPT 6: UNDERSTAND BACKEND SERVICE
===============================================================================

Explain this service code. What validation happens?

```typescript
export const createEvent = async (data: CreateEventInput, userId: string) => {
  // Validate dates
  const startDate = new Date(data.startDate);
  const endDate = new Date(data.endDate);
  
  if (endDate <= startDate) {
    throw new Error("Event end date must be after start date");
  }

  // Validate registration window if provided
  if (data.registrationStartDate && data.registrationEndDate) {
    const regStart = new Date(data.registrationStartDate);
    const regEnd = new Date(data.registrationEndDate);
    
    if (regEnd <= regStart) {
      throw new Error("Registration end date must be after start date");
    }
  }

  // Initialize capabilities with defaults
  const capabilities = {
    registration: false,
    submissions: false,
    review: false,
    teams: false,
    scoring: false,
    sessions: false,
    realtime: false,
    ...data.capabilities
  };

  const event = await Event.create({
    title: data.title,
    description: data.description,
    eventType: data.eventType,
    startDate,
    endDate,
    registrationStartDate: data.registrationStartDate,
    registrationEndDate: data.registrationEndDate,
    registrationForm: data.registrationForm,
    createdBy: new mongoose.Types.ObjectId(userId),
    isPublic: data.isPublic ?? true,
    status: EventStatus.DRAFT,
    capabilities
  });

  return sanitizeEvent(event);
};

export const updateEvent = async (eventId: string, data: Partial<CreateEventInput>, userId: string) => {
  const event = await Event.findById(eventId);
  if (!event) {
    throw new Error("Event not found");
  }

  if (event.createdBy.toString() !== userId) {
    throw new Error("Forbidden: Only creator can update the event");
  }

  const allowed = ["title", "description", "eventType", "startDate", "endDate", "isPublic", "registrationStartDate", "registrationEndDate", "registrationForm"];

  allowed.forEach((key) => {
    if ((data as any)[key] !== undefined) {
      (event as any)[key] = (data as any)[key];
    }
  });

  if (data.capabilities) {
    event.capabilities = {
      ...event.capabilities,
      ...data.capabilities
    };
  }

  await event.save();
  return sanitizeEvent(event);
};
```

Questions:
1. What validations are done before creating event?
2. What does ...data.capabilities do?
3. What is Event.create doing?
4. What is sanitizeEvent?
5. How does updateEvent prevent unauthorized edits?
6. What is event.save() doing?

===============================================================================
PROMPT 7: COMPLETE DATA FLOW
===============================================================================

Trace the complete flow when user creates an event:

FRONTEND (CreateEvent.tsx):
- User fills form
- Clicks "Create Event"
- handleSubmit called
- eventsApi.createEvent(formData) called

API CLIENT (events.api.ts):
- axiosInstance.post('/events', data)
- Sends HTTP POST to backend

BACKEND ROUTE (event.routes.ts):
- POST /events → controller.createEvent

BACKEND CONTROLLER (event.controller.ts):
- Gets data from req.body
- Calls eventService.createEvent

BACKEND SERVICE (event.service.ts):
- Validates data
- Creates event in database
- Returns sanitized event

BACKEND CONTROLLER:
- Sends response back

FRONTEND:
- Gets response
- Navigates to event details page

Questions:
1. Walk me through each step with actual code
2. Where does validation happen?
3. How does data transform at each layer?
4. What if there's an error at any step?
5. How does authentication work (req.user)?

===============================================================================
PROMPT 8: UNDERSTAND SPECIFIC SYNTAX
===============================================================================

Explain these specific code patterns I see:

1. What does this mean?
```typescript
const [formData, setFormData] = useState({...})
```

2. What does this mean?
```typescript
setFormData(prev => ({ ...prev, [name]: value }))
```

3. What does this mean?
```typescript
capability: keyof typeof formData.capabilities
```

4. What does this mean?
```typescript
const response = await eventsApi.createEvent(formData)
```

5. What does this mean?
```typescript
export interface IEvent extends Document
```

6. What does this mean?
```typescript
Partial<Event>
```

7. What does this mean?
```typescript
req.user?.userId
```

8. What does this mean?
```typescript
{ success: boolean; data: Event }
```

===============================================================================
PROMPT 9: HOW TO MODIFY CODE
===============================================================================

I want to add a new field "maxParticipants" to events. Show me exactly what to change:

1. What to add in event.model.ts?
2. What to add in CreateEvent.tsx?
3. What to add in event.service.ts?
4. Any validation needed?

Give me the exact code changes.

===============================================================================
PROMPT 10: DEBUG HELP
===============================================================================

When I [describe your issue], this happens: [error message]

Here's the code:
[paste relevant code]

Help me:
1. What's wrong?
2. How to fix it?
3. How to debug this?

===============================================================================
                              DONE!
===============================================================================

These 10 prompts will get you understanding your code FAST.
Start with Prompt 1 and work through them in order.

Paste each into: https://gemini.google.com
